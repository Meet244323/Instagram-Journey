<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Connected 3D Art Universe</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.3.2/socket.io.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Arial', sans-serif;
        }
        
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: #fff;
            z-index: 100;
            pointer-events: none;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
            opacity: 0.8;
        }
        
        #connection-count {
            font-size: 1.5em;
            margin-bottom: 5px;
        }
        
        #instructions {
            font-size: 0.9em;
            opacity: 0.7;
        }
        
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .particle {
            position: absolute;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            pointer-events: none;
            opacity: 0.8;
            transition: transform 0.3s ease-out;
        }
        
        #portal {
            position: absolute;
            width: 150px;
            height: 150px;
            border-radius: 50%;
            box-shadow: 0 0 60px rgba(0, 255, 255, 0.7);
            border: 2px solid rgba(0, 255, 255, 0.5);
            opacity: 0.8;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 10;
            transition: transform 0.2s ease-out;
        }
        
        .connection-line {
            position: absolute;
            background: rgba(0, 255, 255, 0.3);
            height: 2px;
            transform-origin: 0 0;
            pointer-events: none;
            z-index: 5;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 10px rgba(0, 255, 255, 0.7); }
            50% { box-shadow: 0 0 40px rgba(0, 255, 255, 1); }
            100% { box-shadow: 0 0 10px rgba(0, 255, 255, 0.7); }
        }
        
        #energy {
            position: absolute;
            width: 200px;
            height: 200px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(0,255,255,0.2) 0%, rgba(0,255,255,0) 70%);
            animation: pulse 2s infinite ease-in-out;
            pointer-events: none;
            transform: translate(-50%, -50%);
        }
    </style>
</head>
<body>
    <div id="info">
        <div id="connection-count">Connecting to universe...</div>
        <div id="instructions">Open this page in multiple tabs to see interconnected animations</div>
    </div>
    
    <div id="canvas-container"></div>
    <div id="portal"></div>
    <div id="energy"></div>

    <script>
        // Unique ID for this tab
        const tabId = 'tab-' + Math.random().toString(36).substr(2, 9);
        
        // Configuration
        const config = {
            particleCount: 150,
            maxConnections: 5,
            connectionDistance: 250,
            mouseInfluence: 0.2,
            mouseRadius: 150,
            particleSize: 4,
            backgroundColor: '#000033',
            particleColor: '#00ffff'
        };
        
        // State
        const state = {
            mouseX: 0,
            mouseY: 0,
            particles: [],
            connections: [],
            tabs: [],
            socket: null,
            scene: null,
            camera: null,
            renderer: null,
            objects: []
        };
        
        // Initialize Three.js scene
        function initThreeJS() {
            state.scene = new THREE.Scene();
            state.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            state.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            state.renderer.setSize(window.innerWidth, window.innerHeight);
            state.renderer.setClearColor(0x000000, 0);
            document.getElementById('canvas-container').appendChild(state.renderer.domElement);
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0x404040);
            state.scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            state.scene.add(directionalLight);
            
            // Camera position
            state.camera.position.z = 20;
            
            // Create central torus
            const geometry = new THREE.TorusGeometry(5, 1.5, 16, 100);
            const material = new THREE.MeshPhongMaterial({ 
                color: 0x00ffff,
                emissive: 0x00aaff,
                emissiveIntensity: 0.5,
                shininess: 100,
                wireframe: false,
                transparent: true,
                opacity: 0.9
            });
            const torus = new THREE.Mesh(geometry, material);
            state.scene.add(torus);
            state.objects.push(torus);
            
            // Create orbiting spheres
            for (let i = 0; i < 12; i++) {
                const sphereSize = 0.5 + Math.random() * 1;
                const sphereGeometry = new THREE.SphereGeometry(sphereSize, 32, 32);
                const sphereMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x00aaff,
                    emissive: 0x0066ff,
                    emissiveIntensity: 0.3,
                    transparent: true,
                    opacity: 0.8
                });
                
                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                
                // Position in a circular pattern
                const angle = (i / 12) * Math.PI * 2;
                const distance = 8 + Math.random() * 3;
                sphere.position.x = Math.cos(angle) * distance;
                sphere.position.y = Math.sin(angle) * distance;
                sphere.position.z = (Math.random() - 0.5) * 5;
                
                state.scene.add(sphere);
                state.objects.push({
                    mesh: sphere,
                    angle: angle,
                    distance: distance,
                    speed: 0.01 + Math.random() * 0.02
                });
            }
        }
        
        // Initialize UI particles
        function initParticles() {
            const particlesContainer = document.createElement('div');
            particlesContainer.style.position = 'absolute';
            particlesContainer.style.top = '0';
            particlesContainer.style.left = '0';
            particlesContainer.style.width = '100%';
            particlesContainer.style.height = '100%';
            particlesContainer.style.pointerEvents = 'none';
            document.body.appendChild(particlesContainer);
            
            // Create particles
            for (let i = 0; i < config.particleCount; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.width = config.particleSize + 'px';
                particle.style.height = config.particleSize + 'px';
                particle.style.backgroundColor = config.particleColor;
                
                // Random initial position
                const x = Math.random() * window.innerWidth;
                const y = Math.random() * window.innerHeight;
                
                particle.style.left = x + 'px';
                particle.style.top = y + 'px';
                
                // Store particle in state
                state.particles.push({
                    element: particle,
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: (Math.random() - 0.5) * 0.5,
                    ax: 0,
                    ay: 0,
                    connections: []
                });
                
                particlesContainer.appendChild(particle);
            }
        }
        
        // Initialize websocket connection
        function initSocket() {
            state.socket = io('https://websockets-3dart.glitch.me/', {
                transports: ['websocket'],
                reconnection: true,
                reconnectionAttempts: 5,
                reconnectionDelay: 1000
            });
            
            state.socket.on('connect', () => {
                console.log('Connected to server');
                document.getElementById('connection-count').textContent = 'Connected to quantum network';
                
                // Register this tab
                state.socket.emit('register', {
                    tabId: tabId,
                    type: '3d-art-tab'
                });
            });
            
            state.socket.on('disconnect', () => {
                document.getElementById('connection-count').textContent = 'Disconnected from network';
            });
            
            state.socket.on('tabs-updated', (data) => {
                state.tabs = data.tabs.filter(t => t.tabId !== tabId);
                updateConnectionUI();
            });
            
            state.socket.on('mouse-moved', (data) => {
                if (data.tabId !== tabId) {
                    const portal = document.getElementById('portal');
                    portal.style.left = data.x + 'px';
                    portal.style.top = data.y + 'px';
                    
                    // Update energy center
                    const energy = document.getElementById('energy');
                    energy.style.left = data.x + 'px';
                    energy.style.top = data.y + 'px';
                    
                    // Update 3D objects based on remote mouse
                    state.objects.forEach(obj => {
                        if (obj.mesh) {
                            const mouseNormX = (data.x / window.innerWidth) * 2 - 1;
                            const mouseNormY = -(data.y / window.innerHeight) * 2 + 1;
                            
                            if (obj.mesh) {
                                obj.mesh.position.x += (mouseNormX * 10 - obj.mesh.position.x) * 0.1;
                                obj.mesh.position.y += (mouseNormY * 10 - obj.mesh.position.y) * 0.1;
                            }
                        }
                    });
                    
                    // Update particles
                    state.particles.forEach(p => {
                        const dx = p.x - data.x;
                        const dy = p.y - data.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < config.mouseRadius) {
                            // Push particles away from remote mouse
                            const force = (config.mouseRadius - dist) * 0.0005;
                            p.ax += dx / dist * force;
                            p.ay += dy / dist * force;
                        }
                    });
                }
            });
        }
        
        // Update connection visualization
        function updateConnectionUI() {
            document.getElementById('connection-count').textContent = 
                `${state.tabs.length} other universe${state.tabs.length !== 1 ? 's' : ''} connected`;
                
            // Clear existing connections
            document.querySelectorAll('.connection-line').forEach(el => el.remove());
            
            // Create new connections
            state.tabs.forEach(tab => {
                const line = document.createElement('div');
                line.className = 'connection-line';
                
                // Random position for this connection
                const startX = Math.random() * window.innerWidth;
                const startY = Math.random() * window.innerHeight;
                line.style.left = startX + 'px';
                line.style.top = startY + 'px';
                
                // Animate toward the portal
                const animateLine = () => {
                    const portal = document.getElementById('portal');
                    if (!portal) return;
                    
                    const portalRect = portal.getBoundingClientRect();
                    const portalX = portalRect.left + portalRect.width / 2;
                    const portalY = portalRect.top + portalRect.height / 2;
                    
                    const dx = portalX - startX;
                    const dy = portalY - startY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < 5) {
                        line.remove();
                        return;
                    }
                    
                    line.style.width = Math.min(dist, 200) + 'px';
                    line.style.transform = `rotate(${Math.atan2(dy, dx)}rad)`;
                    
                    requestAnimationFrame(animateLine);
                };
                
                document.body.appendChild(line);
                animateLine();
                
                // Add pulsing effect
                setTimeout(() => {
                    line.style.transition = 'opacity 1s';
                    line.style.opacity = '0';
                    
                    setTimeout(() => {
                        line.remove();
                    }, 1000);
                }, 2000);
            });
        }
        
        // Handle mouse movement
        function onMouseMove(e) {
            state.mouseX = e.clientX;
            state.mouseY = e.clientY;
            
            if (state.socket && state.socket.connected) {
                state.socket.emit('mouse-moved', {
                    tabId: tabId,
                    x: e.clientX,
                    y: e.clientY
                });
            }
            
            // Update portal position
            const portal = document.getElementById('portal');
            portal.style.left = e.clientX + 'px';
            portal.style.top = e.clientY + 'px';
            
            // Update energy center
            const energy = document.getElementById('energy');
            energy.style.left = e.clientX + 'px';
            energy.style.top = e.clientY + 'px';
            
            // Update 3D objects based on mouse
            state.objects.forEach(obj => {
                const mouseNormX = (e.clientX / window.innerWidth) * 2 - 1;
                const mouseNormY = -(e.clientY / window.innerHeight) * 2 + 1;
                
                if (obj.mesh) {
                    obj.mesh.position.x += (mouseNormX * 10 - obj.mesh.position.x) * 0.1;
                    obj.mesh.position.y += (mouseNormY * 10 - obj.mesh.position.y) * 0.1;
                }
                
                if (obj.speed) {
                    obj.angle += obj.speed;
                    obj.mesh.position.x = Math.cos(obj.angle) * obj.distance;
                    obj.mesh.position.y = Math.sin(obj.angle) * obj.distance;
                }
            });
            
            // Update particles based on mouse
            state.particles.forEach(p => {
                const dx = p.x - e.clientX;
                const dy = p.y - e.clientY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < config.mouseRadius) {
                    // Push particles away from mouse
                    const force = (config.mouseRadius - dist) * config.mouseInfluence;
                    p.ax += dx / dist * force;
                    p.ay += dy / dist * force;
                }
            });
        }
        
        // Particle physics
        function updateParticles() {
            // Clear old connections
            state.connections = [];
            
            // Update particle positions
            state.particles.forEach((p, i) => {
                // Apply acceleration
                p.vx += p.ax;
                p.vy += p.ay;
                
                // Apply velocity
                p.x += p.vx;
                p.y += p.vy;
                
                // Reset acceleration
                p.ax = 0;
                p.ay = 0;
                
                // Apply friction
                p.vx *= 0.99;
                p.vy *= 0.99;
                
                // Screen boundaries
                if (p.x < 0) { p.x = 0; p.vx *= -0.5; }
                if (p.x > window.innerWidth) { p.x = window.innerWidth; p.vx *= -0.5; }
                if (p.y < 0) { p.y = 0; p.vy *= -0.5; }
                if (p.y > window.innerHeight) { p.y = window.innerHeight; p.vy *= -0.5; }
                
                // Update DOM position
                p.element.style.transform = `translate(${p.x}px, ${p.y}px)`;
                
                // Find connections
                for (let j = i + 1; j < state.particles.length; j++) {
                    const other = state.particles[j];
                    const dx = p.x - other.x;
                    const dy = p.y - other.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < config.connectionDistance) {
                        state.connections.push({
                            p1: p,
                            p2: other,
                            distance: dist
                        });
                        
                        // Limit connections per particle
                        if (p.connections.length < config.maxConnections && other.connections.length < config.maxConnections) {
                            p.connections.push(other);
                            other.connections.push(p);
                        }
                        
                        // Push particles apart if too close
                        if (dist < 30) {
                            const force = (30 - dist) * 0.01;
                            p.ax += dx / dist * force;
                            p.ay += dy / dist * force;
                            other.ax -= dx / dist * force;
                            other.ay -= dy / dist * force;
                        }
                    }
                }
            });
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Update particles
            updateParticles();
            
            // Update Three.js objects
            state.objects.forEach(obj => {
                if (obj.mesh && obj.speed) {
                    obj.angle += obj.speed;
                    obj.mesh.position.x = Math.cos(obj.angle) * obj.distance;
                    obj.mesh.position.y = Math.sin(obj.angle) * obj.distance;
                    obj.mesh.position.z = Math.sin(Date.now() * 0.001 + obj.angle * 5) * 3;
                }
                
                if (obj.mesh && obj.mesh.geometry.type === 'TorusGeometry') {
                    obj.mesh.rotation.x += 0.01;
                    obj.mesh.rotation.y += 0.005;
                }
            });
            
            // Render Three.js scene
            state.renderer.render(state.scene, state.camera);
        }
        
        // Handle window resize
        function onWindowResize() {
            state.camera.aspect = window.innerWidth / window.innerHeight;
            state.camera.updateProjectionMatrix();
            state.renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Initialize everything
        function init() {
            initThreeJS();
            initParticles();
            initSocket();
            
            // Event listeners
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('resize', onWindowResize);
            
            // Start animation
            animate();
            
            // Periodically check connections
            setInterval(() => {
                if (state.socket) {
                    state.socket.emit('heartbeat', { tabId: tabId });
                }
            }, 5000);
        }
        
        // Start the application
        init();
    </script>
</body>
</html>
